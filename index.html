<!DOCTYPE HTML>
<html>

<head>
  <link rel= "stylesheet" href= "style.css">
</head>

<body id="body">
  <div id="container" class="container"></div>

  <div id="text">
    <p>10 - бомба<br>00 - неправильно поставленный флаг<br> флаг - красный класс добавляемый на предполагаемую бомбу</p>
  </div>

  <div id="time" class="time">
    <span id="minutes">00</span><span>:</span><span id="seconds">00</span>
  </div>

  <div id="bomb" class="time">
    <span id="spanForCounterback"></span><span> / </span><span id="spanForNumberBomb"></span>
  </div>

  <div id="records" class="record">
    <h3>Таблица рекордов</h3>
    <p></p>
  </div>
  <div id="lvl">
    <form action="#" class="blok-form">
      <div class="block-form__title">Уровень сложности</div>
      <div class="block-form__input">
        <div class="radiobuttons" id="mainRadio">
          <div class="radiobuttons__item">
            Легкий
            <input type="radio" value="1" name="nameradio" id="radio1">
          </div>
          <div class="radiobuttons__item">
            Средний
            <input type="radio" value="2" name="nameradio" id="radio2" >
          </div>
          <div class="radiobuttons__item">
            Тяжелый
            <input type="radio" value="3" name="nameradio" id="radio3" checked>
          </div>
        </div>
      </div>
      <button class="button" type="submit">Применить изменения</button>
    </form>
  </div>
  
    <script>
      let row = 16 // количество рядов в таблице
      let column = 16 // количество колонок в таблице
      let numberBomb = 1 // число бомб
      let gameOver // вынесенная функция для того чтобы можно было из внешнего скрипта объявлять gameOver
      let set // вынесенный сет необходимый для проверки отсутсвия победы во внешнем скрипте
      let counterBack // вынесенный счетчик бомб необходимый для проверки отсутсвия победы во внешнем скрипте
      let flag = true // флаг показывающий было ли поражение в прошлой игре при переходе к следующей
      let counterForWinner = 1
      let result
      function superMegaMainFunc(row,column,numberBomb,container,funcForGameOver,flagForGameOver,counterWinner) {
        let timerId // таймер для остановки счетчика
        set = new Set() // сет для бомб
        let counterForBomb = 0 // счетчик бомб используемый при заполнении таблицы бомбами
        let funcClick // для снятия обработчика клика с ячейки из внешней функции
        let funcContextMenu //для снятия обработчика правой кнопкой мыши с ячейки из внешней функции
        counterBack = 0
        function createTable(row,column,container) {
          let table = document.createElement('table') // создаем таблицу
          for(let i = 0; i < row; i++) {
            let tr = document.createElement('tr')
            for(let j = 0; j < column; j++) {
              let td = document.createElement('td')
              tr.append(td)
            }
            table.append(tr)
          }
          container.append(table)
        }
        createTable(row, column ,container)

        let tds = document.querySelectorAll('td')
        let trs = document.querySelectorAll('tr')

        function random(min, max) {
        let rand =  (((min - 0.5) + Math.random() * (max - min + 0.5)).toFixed()) // вспомогательная функция для рандомного значения
        return Math.round(rand)
        }
      
        function addBomb(num) { // передаем количество бомб

          for(let td of tds) {

            if(counterForBomb >= num) { // если необходимое количество бомб прекращаем работу цикла
              return
            }

            let probability = random(1,100)  // возвращает псевдо случайное число от 1 до 100
            if(probability < 10) { // вероятность появления бомбы в ячейке 10%
              if(td.lastElementChild) continue // если уже есть бомба пропускаем такую ячейку
              td.innerHTML = '<span>10</span>' // добавляем бомбу
              counterForBomb++ // увеличиваем счетчик
            } 
          }
          if(counterForBomb < num) { // если бомб меньше чем нужно запускаем снова цикл
            addBomb(num)
          }
        }
        addBomb(numberBomb)

        function addTip() {
            for(let i = 0; i < trs.length; i++) {
              for(let j = 0; j < trs.length; j++) {
                let counter = 0 // если рядом найдена бомба увеличиваем счетчик
                if(trs[i].children[j].hasChildNodes()) continue // если элемент имеет детей значит это бомба(имеет span) пропускаем этот элемент


                if(trs[i].children[j - 1]) { // обработка предыдущего элемента
                  if(trs[i].children[j - 1].textContent == '10') {
                    counter++
                  }
                } 

                if(trs[i].children[j + 1]) { // обработка следующего элемента
                  if(trs[i].children[j + 1].textContent == '10') {
                    counter++
                  }
                } 

                if(trs[i - 1]) { // обработка верхнего элемента
                  if(trs[i - 1].children[j].textContent == '10') {
                    counter++
                  }
                } 

                if(trs[i + 1]) { // обработка нижнего элемента
                  if(trs[i + 1].children[j].textContent == '10') {
                    counter++
                  }
                } 

                if(trs[i - 1]) { // обработка верхнего крайнего левого элемента
                  if(trs[i - 1].children[j - 1]) {
                    if(trs[i - 1].children[j - 1].textContent == '10') {
                    counter++
                    }
                  }
                } 

                if(trs[i - 1]) { // обработка верхнего крайнего правого элемента
                  if(trs[i - 1].children[j + 1]) {
                    if(trs[i - 1].children[j + 1].textContent == '10') {
                    counter++
                    }
                  }
                } 

                if(trs[i + 1]) { // обработка нижнего крайнего левого элемента
                  if(trs[i + 1].children[j - 1]) {
                    if(trs[i + 1].children[j - 1].textContent == '10') {
                    counter++
                    }
                  }
                } 

                if(trs[i + 1]) { // обработка нижнего крайнего правого элемента
                  if(trs[i + 1].children[j + 1]) {
                    if(trs[i + 1].children[j + 1].textContent == '10') {
                    counter++
                    }
                  }
                } 


                trs[i].children[j].textContent = counter
              }
            }
          }
        addTip()

        function createHiddenElement() {
          for(let td of tds) { // добавляем каждой ячейке скрывающий элемент
          let hidden = document.createElement('div')
          hidden.classList.add('hidden')
          td.append(hidden)
          }
        }
        createHiddenElement()
        
        gameOver = function () {
          result = confirm('Game over! Do you want to start a new game?') 
          if(result) {
            alert('game restarted') // доработать перезапуск игры 
            clearInterval(timerId)
            // // конструкция для перезапуска игры
            let innerRow = row
            let innerColumn = column
            let innerNumberBomb = numberBomb
            flag = true
            seconds.textContent = '00'
            minutes.textContent = '00'
            container.remove()
            let div = document.createElement('div')
            body.prepend(div)
            div.classList.add('container')
            div.id = 'container'
            superMegaMainFunc(innerRow,innerColumn,innerNumberBomb,div,gameOver,flag,counterForWinner)
            // //
          } 
          else {
            for(let td of tds) { // если подорвался то окрываются все оставшиеся мины
            
            if(td.children.length == 2) {
              if(td.lastElementChild.classList.contains('bomb')) continue // если мина разгадана правильно то она остается под флагом и не открывается
              td.lastElementChild.remove()
            }
            if(td.children.length == 1) { // если флаг был выбран неправильно
              if(td.lastElementChild.classList.contains('bomb')) {
                td.lastElementChild.remove()
                td.textContent = '00' // доработка: ячейки не должны расширяться при добавлении данного значения
              }
            }
          }
          
          document.removeEventListener('click', funcClick) // снимаем все обработчики и останавливаем таймер
          document.removeEventListener('contextmenu', funcContextMenu)
          clearInterval(timerId)
          }
        }
        
        
        function gameWinner(event1,functions1,event2,functions2) {
          alert('Game WON!!! I really congratulate you') // снимаем все обработчики и останавливаем таймер

          records.lastElementChild.innerHTML += `${counterForWinner})<span>${minutes.textContent}</span><span>:</span><span>${seconds.textContent}</span><br>`
          counterForWinner++ // пушим время в массив для таблицы рекордов

          document.removeEventListener(event1, functions1)
          document.removeEventListener(event2, functions2)
          clearInterval(timerId)
        }
        
        function addListenerForRemoveElementAndOpenEmptyElement() {
          document.addEventListener('click', funcClick = function (event) {
          let target = event.target.closest('td')
          if(!target) return
          if(!container.contains(target)) return
          if(target.lastElementChild) {
            if(target.lastElementChild.classList.contains('bomb')) return
            target.lastElementChild.remove() // по клику на ячейку открывается скрывающий элемент
          }
          

         
          if(target.textContent == '0') {
            let counterRow = 0
            let counterColumn = 0

            for(let tr of trs) { // узнаем номер ряда выбранной ячейки
              counterRow++
              if(target.parentNode == tr) {
                break // прекращаем цикл когда цель найдена
              }
            }
            for(let td of tds) { // узнаем номер столбца выбранной ячейки
              counterColumn++
              if(target == td) {
                counterColumn = counterColumn - (counterRow - 1) * column
                break // прекращаем цикл когда цель найдена
              }
            }
            
            if(trs[counterRow]) { // обрабатываем наличие этого ряда
              if(trs[counterRow].children[counterColumn]){ // есть ли вообще такая ячейка в этом ряду
                if(trs[counterRow].children[counterColumn].lastElementChild) { // есть ли дочерний элемент(для проверки на наличие класса у этой ячейки)
                  if(!(trs[counterRow].children[counterColumn].lastElementChild.classList.contains('bomb'))) { // если нет класса "бомба" продолжаем
                    trs[counterRow].children[counterColumn].lastElementChild.remove() // обработка нижнего правого элемента
                  }
                }
              }
          

              if(trs[counterRow].children[counterColumn - 1]) { // обработка нижнего элемента
                if(trs[counterRow].children[counterColumn - 1].lastElementChild) {
                  if((!trs[counterRow].children[counterColumn - 1].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow].children[counterColumn - 1].lastElementChild.remove()
                  }
                }
              }

              if(trs[counterRow].children[counterColumn - 2]) { // обработка нижнего левого элемента
                if(trs[counterRow].children[counterColumn - 2].lastElementChild) {
                  if(!(trs[counterRow].children[counterColumn - 2].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow].children[counterColumn - 2].lastElementChild.remove()
                  }
                }
              }
            }
            

            if(trs[counterRow - 1]) {
              if(trs[counterRow - 1].children[counterColumn - 2]) { // обработка левого элемента
                if(trs[counterRow - 1].children[counterColumn - 2].lastElementChild) {
                  if(!(trs[counterRow - 1].children[counterColumn - 2].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow - 1].children[counterColumn - 2].lastElementChild.remove()
                  }
                }
              }
            

              if(trs[counterRow - 1].children[counterColumn]) { // обработка правого элемента
                if(trs[counterRow - 1].children[counterColumn].lastElementChild) {
                  if(!(trs[counterRow - 1].children[counterColumn].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow - 1].children[counterColumn].lastElementChild.remove()
                  }
                }
              }
            }
            
            
            if(trs[counterRow - 2]) {
              if(trs[counterRow - 2].children[counterColumn - 2]) { // обработка верхнего левого элемента
                if(trs[counterRow - 2].children[counterColumn - 2].lastElementChild) {
                  if(!(trs[counterRow - 2].children[counterColumn - 2].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow - 2].children[counterColumn - 2].lastElementChild.remove()
                  }
                }
              }
          
            
              if(trs[counterRow - 2].children[counterColumn - 1]) { // обработка верхнего элемента
                if(trs[counterRow - 2].children[counterColumn - 1].lastElementChild) {
                  if(!(trs[counterRow - 2].children[counterColumn - 1].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow - 2].children[counterColumn - 1].lastElementChild.remove()
                  }
                }
              }

              if(trs[counterRow - 2].children[counterColumn]) { // обработка верхнего правого элемента
                if(trs[counterRow - 2].children[counterColumn].lastElementChild) {
                  if(!(trs[counterRow - 2].children[counterColumn].lastElementChild.classList.contains('bomb'))) {
                    trs[counterRow - 2].children[counterColumn].lastElementChild.remove()
                  }
                }
              }
            }
          }
          
          if(target.textContent == '10') { // если попали на бомбу то подрыв
            gameOver()
            flag = false
            console.log(flag)
          }
        
          })
        }
        addListenerForRemoveElementAndOpenEmptyElement()// доработать открытие пустых ячеек
        
        function addCounter() {
          document.addEventListener('click', function func3(event) { // по клику на ячейку запускается счетчик
          let target = event.target.closest('td')
          if(!target) return
          if(!container.contains(target)) return

          let counterForSeconds = 0
          let counterForMinutes = 0

          timerId =  setInterval(() => {
            counterForSeconds++
            if(counterForSeconds < 60) {

              if(counterForSeconds < 10) {
                counterForSeconds = '0' + +counterForSeconds
              }
              seconds.textContent = counterForSeconds
            } else {
              counterForSeconds = 0
              counterForMinutes++

              if(counterForMinutes < 60) {
                minutes.textContent = counterForMinutes
                if(counterForMinutes < 10) {
                minutes.textContent = '0' + +counterForMinutes
                }
              }
            }
          },1000)

          this.removeEventListener('click', func3, true)

          },true)
        }
        addCounter()
        
        function addListenerForContextMenu() {
          document.addEventListener('contextmenu',funcContextMenu = function (event) {
          let target = event.target.closest('td')
          if(!target) return
          if(!container.contains(target)) return

        
          if(target.lastElementChild.classList.contains('bomb')) { // обратный счетчик для бомб
            target.lastElementChild.classList.remove('bomb')
            counterBack--
          } else {
            target.lastElementChild.classList.add('bomb')
            counterBack++
          }

          event.preventDefault() // убрать всплытие стандартного контекстного меню
          if(target.textContent == '10') {  // если мина была выбрана неправильно можно отменить действие и поменять флаги только если есть запас флагов
            if(target.lastElementChild.classList.contains('bomb')) {
              set.delete(target)
            } else{
              set.add(target)
            }
          }

          spanForCounterback.textContent = counterBack

          if(set.size == 0 & counterBack == numberBomb) { // если нет бомб в сете и число флагов == числу бомб - победа
            gameWinner('click', funcClick,'contextmenu', funcContextMenu)
          }
        
        })
        } 
        addListenerForContextMenu()
        
        function addBombToSet() {
          for(let td of tds) { // если содержится бомба в ячейке тогда эта ячейка добавляется в сет
          if(td.textContent == '10') {
            set.add(td)
          }
        }
        console.log(set)

        spanForCounterback.textContent = counterBack // добавление счетчика бомб в форму
        spanForNumberBomb.textContent = numberBomb // добавление изначального количества бомб в форму
        }
        addBombToSet()
        
        function addColorForNumber() {
          let arr = ['black','blue','green','grown','red','aqua','blueviolet', 'coral', 'darkorange']
          for(let td of tds) {
            for(let i = 0; i < arr.length; i++) {
              if(td.textContent == `${i}`) {
                td.style.color = arr[i]
              }
            }
          }
        }
        addColorForNumber()
      }

   superMegaMainFunc(row,column,numberBomb,container,gameOver,flag,counterForWinner)

    function addRadioButtons() {
      
      radio1.addEventListener('click', function() {
        let result = confirm('if you will change the level game is over. Do you want to do it?')
        if(result) {
          helpForRadioButtons(8,8,10)
        } else {
          this.checked = false 
        }
      })
      radio2.addEventListener('click', function() {
        let result = confirm('if you will change the level game is over. Do you want to do it?')
        if(result) {
        helpForRadioButtons(16,16,40)
        }
        else {
          this.checked = false
        }
      })
      radio3.addEventListener('click', function() {
        let result = confirm('if you will change the level game is over. Do you want to do it?')
        if(result) {
        helpForRadioButtons(25,25,100)
        }
        else {
          this.checked = false
        }
      })
    }
    
    function helpForRadioButtons (numRow,numColumn,numNumberBomb) {
      
        if(!(set.size == 0 & counterBack == numberBomb)) {
          if(flag) {
            gameOver()
          }
        }
        if(result){
          row = numRow
        column = numColumn
        numberBomb = numNumberBomb
        flag = true
        seconds.textContent = '00'
        minutes.textContent = '00'
        container.remove()
        let div = document.createElement('div')
        body.prepend(div)
        div.classList.add('container')
        div.id = 'container'
        superMegaMainFunc(row,column,numberBomb,div,gameOver,flag,counterForWinner)
        }
         else {
          return
        }
       result = false
    }
    addRadioButtons()
    
    </script>
     // доработать открытие пустых ячеек
     // сделать таблицу рекордов Fokkewolfe1945c? 549193
     // доработать перезапуск игры
     // при переходе из незаконченной игры должен возникать другой confirm
     при нажатии кнопки отмена продолжается переход на новый уровень 
</body>
</html>
